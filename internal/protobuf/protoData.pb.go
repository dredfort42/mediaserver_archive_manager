// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.35.1
// 	protoc        v6.32.1
// source: protoData.proto

package __

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// System Digest Entry
// Topic settings:
// - cleanup.policy=compact,delete \
// - retention.ms=60000 \
// - segment.ms=6000 \
// - min.cleanable.dirty.ratio=0.01
// ---
// Kafka topic: digest
// Key for Kafka message: ${ServiceUUID}
type ProtoServiceDigest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// *
	// Service UUID (unique identifier)
	ServiceUuid string `protobuf:"bytes,1,opt,name=service_uuid,json=serviceUuid,proto3" json:"service_uuid,omitempty"`
	// *
	// Service name (e.g., "mediaserver_manager", "rtsp_streamer", etc.)
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// *
	// Service version
	ServiceVersion string `protobuf:"bytes,3,opt,name=service_version,json=serviceVersion,proto3" json:"service_version,omitempty"`
	// *
	// Service status (reusing your existing codes)
	// 100 - Unknown
	// 101 - Starting
	// 102 - Ready
	// 103 - Degraded
	// 104 - Maintenance
	// 105 - Stopping
	// 106 - Stopped
	// 107 - Error
	ServiceStatusCode uint32 `protobuf:"varint,4,opt,name=service_status_code,json=serviceStatusCode,proto3" json:"service_status_code,omitempty"`
	// *
	// Service endpoints (host:port)
	Endpoints []string `protobuf:"bytes,5,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	// *
	// Last heartbeat timestamp
	LastHeartbeat uint64 `protobuf:"varint,6,opt,name=last_heartbeat,json=lastHeartbeat,proto3" json:"last_heartbeat,omitempty"` // Unix timestamp in milliseconds
}

func (x *ProtoServiceDigest) Reset() {
	*x = ProtoServiceDigest{}
	mi := &file_protoData_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoServiceDigest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoServiceDigest) ProtoMessage() {}

func (x *ProtoServiceDigest) ProtoReflect() protoreflect.Message {
	mi := &file_protoData_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtoServiceDigest.ProtoReflect.Descriptor instead.
func (*ProtoServiceDigest) Descriptor() ([]byte, []int) {
	return file_protoData_proto_rawDescGZIP(), []int{0}
}

func (x *ProtoServiceDigest) GetServiceUuid() string {
	if x != nil {
		return x.ServiceUuid
	}
	return ""
}

func (x *ProtoServiceDigest) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *ProtoServiceDigest) GetServiceVersion() string {
	if x != nil {
		return x.ServiceVersion
	}
	return ""
}

func (x *ProtoServiceDigest) GetServiceStatusCode() uint32 {
	if x != nil {
		return x.ServiceStatusCode
	}
	return 0
}

func (x *ProtoServiceDigest) GetEndpoints() []string {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *ProtoServiceDigest) GetLastHeartbeat() uint64 {
	if x != nil {
		return x.LastHeartbeat
	}
	return 0
}

// *
// Camera Properties Entry
// Topic settings:
// - cleanup.policy=compact
// - retention.ms=300000
// - delete.retention.ms=300000
// - segment.ms=30000
// - min.cleanable.dirty.ratio=0.01
// ---
// Kafka topic: cameras
// Key for Kafka message:  ${CameraUUID}
type ProtoCamera struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// *
	// Camera UUID (same as the message key)
	CameraUuid string `protobuf:"bytes,1,opt,name=camera_uuid,json=cameraUuid,proto3" json:"camera_uuid,omitempty"`
	// *
	// Main RTSP URL
	MainRtspUrl string `protobuf:"bytes,2,opt,name=main_rtsp_url,json=mainRtspUrl,proto3" json:"main_rtsp_url,omitempty"`
	// *
	// Main connection type
	// OnDemand:
	//
	//	0 - standby
	//	1 - active
	//
	// Permanent:
	//
	//	8 - always on
	MainConnectionType uint32 `protobuf:"varint,3,opt,name=main_connection_type,json=mainConnectionType,proto3" json:"main_connection_type,omitempty"`
	// *
	// Sub RTSP URL
	SubRtspUrl string `protobuf:"bytes,4,opt,name=sub_rtsp_url,json=subRtspUrl,proto3" json:"sub_rtsp_url,omitempty"`
	// *
	// Sub connection type
	// OnDemand:
	//
	//	0 - standby
	//	1 - active
	//
	// Permanent:
	//
	//	8 - always on
	SubConnectionType uint32 `protobuf:"varint,5,opt,name=sub_connection_type,json=subConnectionType,proto3" json:"sub_connection_type,omitempty"`
	// *
	// Status code
	// 0 - Status OFF
	// 1 - Status ON
	StatusCode uint32 `protobuf:"varint,6,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	// *
	// Camera connector UUID
	// Instance that this camera is attached to.
	CameraConnectorUuid string `protobuf:"bytes,7,opt,name=camera_connector_uuid,json=cameraConnectorUuid,proto3" json:"camera_connector_uuid,omitempty"`
	// *
	// Archive retention days
	// Number of days to retain the archived footage.
	// 0 - means no archiving.
	ArchiveRetentionDays uint32 `protobuf:"varint,8,opt,name=archive_retention_days,json=archiveRetentionDays,proto3" json:"archive_retention_days,omitempty"`
}

func (x *ProtoCamera) Reset() {
	*x = ProtoCamera{}
	mi := &file_protoData_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoCamera) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoCamera) ProtoMessage() {}

func (x *ProtoCamera) ProtoReflect() protoreflect.Message {
	mi := &file_protoData_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtoCamera.ProtoReflect.Descriptor instead.
func (*ProtoCamera) Descriptor() ([]byte, []int) {
	return file_protoData_proto_rawDescGZIP(), []int{1}
}

func (x *ProtoCamera) GetCameraUuid() string {
	if x != nil {
		return x.CameraUuid
	}
	return ""
}

func (x *ProtoCamera) GetMainRtspUrl() string {
	if x != nil {
		return x.MainRtspUrl
	}
	return ""
}

func (x *ProtoCamera) GetMainConnectionType() uint32 {
	if x != nil {
		return x.MainConnectionType
	}
	return 0
}

func (x *ProtoCamera) GetSubRtspUrl() string {
	if x != nil {
		return x.SubRtspUrl
	}
	return ""
}

func (x *ProtoCamera) GetSubConnectionType() uint32 {
	if x != nil {
		return x.SubConnectionType
	}
	return 0
}

func (x *ProtoCamera) GetStatusCode() uint32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *ProtoCamera) GetCameraConnectorUuid() string {
	if x != nil {
		return x.CameraConnectorUuid
	}
	return ""
}

func (x *ProtoCamera) GetArchiveRetentionDays() uint32 {
	if x != nil {
		return x.ArchiveRetentionDays
	}
	return 0
}

// *
// Camera Stream Parameters Entry
// Topic settings:
// - cleanup.policy=compact,delete \
// - retention.ms=10000 \
// - segment.ms=1000 \
// - min.cleanable.dirty.ratio=0.01
// ---
// Kafka topic: camera_stream_parameters
// Key for Kafka message: ${CameraUUID}
type ProtoCameraStreamParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// *
	// State code
	// 0 - Not connected
	// 1 - Connecting
	// 2 - Connection established
	// 3 - Connection closed
	CameraConnectionStateCode uint32 `protobuf:"varint,1,opt,name=camera_connection_state_code,json=cameraConnectionStateCode,proto3" json:"camera_connection_state_code,omitempty"`
	// *
	// Average bitrate of the video stream
	VideoAvgBitrate uint32 `protobuf:"varint,2,opt,name=video_avg_bitrate,json=videoAvgBitrate,proto3" json:"video_avg_bitrate,omitempty"`
	// *
	// Bitrate of the stream
	VideoBitrate uint32 `protobuf:"varint,3,opt,name=video_bitrate,json=videoBitrate,proto3" json:"video_bitrate,omitempty"`
	// *
	// Frames per second
	VideoFps float32 `protobuf:"fixed32,4,opt,name=video_fps,json=videoFps,proto3" json:"video_fps,omitempty"`
	// *
	// Width of video in pixels
	VideoWidth int32 `protobuf:"varint,5,opt,name=video_width,json=videoWidth,proto3" json:"video_width,omitempty"`
	// *
	// Height of video in pixels
	VideoHeight int32 `protobuf:"varint,6,opt,name=video_height,json=videoHeight,proto3" json:"video_height,omitempty"`
}

func (x *ProtoCameraStreamParameters) Reset() {
	*x = ProtoCameraStreamParameters{}
	mi := &file_protoData_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoCameraStreamParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoCameraStreamParameters) ProtoMessage() {}

func (x *ProtoCameraStreamParameters) ProtoReflect() protoreflect.Message {
	mi := &file_protoData_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtoCameraStreamParameters.ProtoReflect.Descriptor instead.
func (*ProtoCameraStreamParameters) Descriptor() ([]byte, []int) {
	return file_protoData_proto_rawDescGZIP(), []int{2}
}

func (x *ProtoCameraStreamParameters) GetCameraConnectionStateCode() uint32 {
	if x != nil {
		return x.CameraConnectionStateCode
	}
	return 0
}

func (x *ProtoCameraStreamParameters) GetVideoAvgBitrate() uint32 {
	if x != nil {
		return x.VideoAvgBitrate
	}
	return 0
}

func (x *ProtoCameraStreamParameters) GetVideoBitrate() uint32 {
	if x != nil {
		return x.VideoBitrate
	}
	return 0
}

func (x *ProtoCameraStreamParameters) GetVideoFps() float32 {
	if x != nil {
		return x.VideoFps
	}
	return 0
}

func (x *ProtoCameraStreamParameters) GetVideoWidth() int32 {
	if x != nil {
		return x.VideoWidth
	}
	return 0
}

func (x *ProtoCameraStreamParameters) GetVideoHeight() int32 {
	if x != nil {
		return x.VideoHeight
	}
	return 0
}

// Kafka topic: camera_stream_codecs
// Key for Kafka message: ${StreamType}_${MediaType}
// - StreamType: main/sub
// - MediaType: audio/video/data/subtitles/attachment
type ProtoCameraStreamCodecs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// *
	// General type of the encoded data.
	// Identifies the type of codec used for the media stream:
	//
	//	AVMEDIA_TYPE_VIDEO
	//	AVMEDIA_TYPE_AUDIO
	//	AVMEDIA_TYPE_DATA       ///< Opaque data information usually continuous
	//	AVMEDIA_TYPE_SUBTITLE
	//	AVMEDIA_TYPE_ATTACHMENT ///< Opaque data information usually sparse
	CodecType int32 `protobuf:"varint,1,opt,name=codec_type,json=codecType,proto3" json:"codec_type,omitempty"`
	// *
	// Specific type of the encoded data (the codec used).
	// Identifies the codec used for the stream:
	//
	//	video - H.264, H.265, etc.
	//	audio - AAC, MP3, etc.
	CodecId int32 `protobuf:"varint,2,opt,name=codec_id,json=codecId,proto3" json:"codec_id,omitempty"`
	// *
	// Additional information about the codec (corresponds to the AVI FOURCC).
	CodecTag uint32 `protobuf:"varint,3,opt,name=codec_tag,json=codecTag,proto3" json:"codec_tag,omitempty"`
	// *
	// Extra binary data needed for initializing the decoder, codec-dependent.
	Extradata []byte `protobuf:"bytes,4,opt,name=extradata,proto3" json:"extradata,omitempty"`
	// *
	// Size of the extradata content in bytes.
	ExtradataSize int32 `protobuf:"varint,5,opt,name=extradata_size,json=extradataSize,proto3" json:"extradata_size,omitempty"`
	// *
	// Format of the codec data:
	//
	//	video - the pixel format, the value corresponds to enum AVPixelFormat.
	//	audio - the sample format, the value corresponds to enum AVSampleFormat.
	Format int32 `protobuf:"varint,6,opt,name=format,proto3" json:"format,omitempty"`
	// *
	// Name of the codec data format.
	FormatName string `protobuf:"bytes,7,opt,name=format_name,json=formatName,proto3" json:"format_name,omitempty"`
	// *
	// The average bitrate of the encoded data (in bits per second).
	BitRate uint64 `protobuf:"varint,8,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	// *
	// The number of bits per sample in the codedwords.
	//
	// This is basically the bitrate per sample.
	// It is mandatory for a bunch of formats to actually decode them.
	// It's the number of bits for one sample in the actual coded bitstream.
	//
	// This could be for example 4 for ADPCM.
	// For PCM formats this matches bits_per_raw_sample.
	// Can be 0.
	BitsPerCodedSample int32 `protobuf:"varint,9,opt,name=bits_per_coded_sample,json=bitsPerCodedSample,proto3" json:"bits_per_coded_sample,omitempty"`
	// *
	// This is the number of valid bits in each output sample.
	// If the sample format has more bits, the least significant bits are additional padding bits, which are always 0.
	// Use right shifts to reduce the sample to its actual size.
	// For example, audio formats with 24 bit samples will have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
	// To get the original sample use "(int32_t)sample >> 8"."
	//
	// For ADPCM this might be 12 or 16 or similar.
	// Can be 0.
	BitsPerRawSample int32 `protobuf:"varint,10,opt,name=bits_per_raw_sample,json=bitsPerRawSample,proto3" json:"bits_per_raw_sample,omitempty"`
	// *
	// Codec-specific bitstream restrictions that the stream conforms to.
	Profile int32 `protobuf:"varint,11,opt,name=profile,proto3" json:"profile,omitempty"`
	Level   int32 `protobuf:"varint,12,opt,name=level,proto3" json:"level,omitempty"`
	// *
	// Video only.
	//
	// The dimensions of the video frame in pixels.
	Width  int32 `protobuf:"varint,13,opt,name=width,proto3" json:"width,omitempty"`
	Height int32 `protobuf:"varint,14,opt,name=height,proto3" json:"height,omitempty"`
	// *
	// Video only.
	//
	// The aspect ratio (width / height) which a single pixel should have when displayed.
	// When the aspect ratio is unknown / undefined, the numerator should be set to 0 (the denominator may have any value).
	//
	// @note sample_aspect_ratio = sample_aspect_ratio_num / sample_aspect_ratio_den
	SampleAspectRatioNum int32 `protobuf:"varint,15,opt,name=sample_aspect_ratio_num,json=sampleAspectRatioNum,proto3" json:"sample_aspect_ratio_num,omitempty"`
	SampleAspectRatioDen int32 `protobuf:"varint,16,opt,name=sample_aspect_ratio_den,json=sampleAspectRatioDen,proto3" json:"sample_aspect_ratio_den,omitempty"`
	// *
	// Video only.
	//
	// Number of frames per second, for streams with constant frame durations.
	// Should be set to { 0, 1 } when some frames have differing durations or if the value is not known.
	//
	// @note framerate = framerate_num / framerate_den
	// This field correponds to values that are stored in codec-level headers and is typically overridden by container/transport-layer timestamps, when available.
	// It should thus be used only as a last resort, when no higher-level timing information is available.
	FramerateNum int32 `protobuf:"varint,17,opt,name=framerate_num,json=framerateNum,proto3" json:"framerate_num,omitempty"`
	FramerateDen int32 `protobuf:"varint,18,opt,name=framerate_den,json=framerateDen,proto3" json:"framerate_den,omitempty"`
	// *
	// Video only.
	//
	// The order of the fields in interlaced video.
	FieldOrder int32 `protobuf:"varint,19,opt,name=field_order,json=fieldOrder,proto3" json:"field_order,omitempty"`
	// *
	// Video only.
	//
	// Additional colorspace characteristics.
	ColorRange     int32 `protobuf:"varint,20,opt,name=color_range,json=colorRange,proto3" json:"color_range,omitempty"`
	ColorPrimaries int32 `protobuf:"varint,21,opt,name=color_primaries,json=colorPrimaries,proto3" json:"color_primaries,omitempty"`
	ColorTrc       int32 `protobuf:"varint,22,opt,name=color_trc,json=colorTrc,proto3" json:"color_trc,omitempty"`
	ColorSpace     int32 `protobuf:"varint,23,opt,name=color_space,json=colorSpace,proto3" json:"color_space,omitempty"`
	ChromaLocation int32 `protobuf:"varint,24,opt,name=chroma_location,json=chromaLocation,proto3" json:"chroma_location,omitempty"`
	// *
	// Video only.
	//
	// Number of delayed frames.
	VideoDelay int32 `protobuf:"varint,25,opt,name=video_delay,json=videoDelay,proto3" json:"video_delay,omitempty"`
	// *
	// Audio only.
	//
	// The channel layout and number of channels.
	//
	// Mandatory:
	//
	//	Channel order used in this layout.
	//	Number of channels in this layout.
	ChLayoutOrder      int32 `protobuf:"varint,26,opt,name=ch_layout_order,json=chLayoutOrder,proto3" json:"ch_layout_order,omitempty"`
	ChLayoutNbChannels int32 `protobuf:"varint,27,opt,name=ch_layout_nb_channels,json=chLayoutNbChannels,proto3" json:"ch_layout_nb_channels,omitempty"`
	// *
	// Audio only.
	//
	// The number of audio samples per second.
	SampleRate int32 `protobuf:"varint,28,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	// *
	// Audio only.
	//
	// The number of bytes per coded audio frame, required by some formats.
	//
	// Corresponds to nBlockAlign in WAVEFORMATEX.
	BlockAlign int32 `protobuf:"varint,29,opt,name=block_align,json=blockAlign,proto3" json:"block_align,omitempty"`
	// *
	// Audio only.
	//
	// Audio frame size, if known. Required by some formats to be static.
	FrameSize int32 `protobuf:"varint,30,opt,name=frame_size,json=frameSize,proto3" json:"frame_size,omitempty"`
	// *
	// Audio only.
	//
	// The amount of padding (in samples) inserted by the encoder at the beginning of the audio.
	// I.e. this number of leading decoded samples must be discarded by the caller to get the original audio without leading padding.
	InitialPadding int32 `protobuf:"varint,31,opt,name=initial_padding,json=initialPadding,proto3" json:"initial_padding,omitempty"`
	// *
	// Audio only.
	//
	// The amount of padding (in samples) appended by the encoder to the end of the audio.
	// I.e. this number of decoded samples must be discarded by the caller from the end of the stream to get the original audio without any trailing padding.
	TrailingPadding int32 `protobuf:"varint,32,opt,name=trailing_padding,json=trailingPadding,proto3" json:"trailing_padding,omitempty"`
	// *
	// Audio only.
	//
	// Number of samples to skip after a discontinuity.
	SeekPreroll int32 `protobuf:"varint,33,opt,name=seek_preroll,json=seekPreroll,proto3" json:"seek_preroll,omitempty"`
	// *
	// Stream index UUID.
	// This is a unique identifier for the stream index formed by the <camera UUID> + <_stream type> + <_media type>.
	StreamIndexUuid string `protobuf:"bytes,34,opt,name=stream_index_uuid,json=streamIndexUuid,proto3" json:"stream_index_uuid,omitempty"`
}

func (x *ProtoCameraStreamCodecs) Reset() {
	*x = ProtoCameraStreamCodecs{}
	mi := &file_protoData_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoCameraStreamCodecs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoCameraStreamCodecs) ProtoMessage() {}

func (x *ProtoCameraStreamCodecs) ProtoReflect() protoreflect.Message {
	mi := &file_protoData_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtoCameraStreamCodecs.ProtoReflect.Descriptor instead.
func (*ProtoCameraStreamCodecs) Descriptor() ([]byte, []int) {
	return file_protoData_proto_rawDescGZIP(), []int{3}
}

func (x *ProtoCameraStreamCodecs) GetCodecType() int32 {
	if x != nil {
		return x.CodecType
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetCodecId() int32 {
	if x != nil {
		return x.CodecId
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetCodecTag() uint32 {
	if x != nil {
		return x.CodecTag
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetExtradata() []byte {
	if x != nil {
		return x.Extradata
	}
	return nil
}

func (x *ProtoCameraStreamCodecs) GetExtradataSize() int32 {
	if x != nil {
		return x.ExtradataSize
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFormat() int32 {
	if x != nil {
		return x.Format
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFormatName() string {
	if x != nil {
		return x.FormatName
	}
	return ""
}

func (x *ProtoCameraStreamCodecs) GetBitRate() uint64 {
	if x != nil {
		return x.BitRate
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetBitsPerCodedSample() int32 {
	if x != nil {
		return x.BitsPerCodedSample
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetBitsPerRawSample() int32 {
	if x != nil {
		return x.BitsPerRawSample
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetProfile() int32 {
	if x != nil {
		return x.Profile
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetLevel() int32 {
	if x != nil {
		return x.Level
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetWidth() int32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetHeight() int32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetSampleAspectRatioNum() int32 {
	if x != nil {
		return x.SampleAspectRatioNum
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetSampleAspectRatioDen() int32 {
	if x != nil {
		return x.SampleAspectRatioDen
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFramerateNum() int32 {
	if x != nil {
		return x.FramerateNum
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFramerateDen() int32 {
	if x != nil {
		return x.FramerateDen
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFieldOrder() int32 {
	if x != nil {
		return x.FieldOrder
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetColorRange() int32 {
	if x != nil {
		return x.ColorRange
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetColorPrimaries() int32 {
	if x != nil {
		return x.ColorPrimaries
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetColorTrc() int32 {
	if x != nil {
		return x.ColorTrc
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetColorSpace() int32 {
	if x != nil {
		return x.ColorSpace
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetChromaLocation() int32 {
	if x != nil {
		return x.ChromaLocation
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetVideoDelay() int32 {
	if x != nil {
		return x.VideoDelay
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetChLayoutOrder() int32 {
	if x != nil {
		return x.ChLayoutOrder
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetChLayoutNbChannels() int32 {
	if x != nil {
		return x.ChLayoutNbChannels
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetSampleRate() int32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetBlockAlign() int32 {
	if x != nil {
		return x.BlockAlign
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetFrameSize() int32 {
	if x != nil {
		return x.FrameSize
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetInitialPadding() int32 {
	if x != nil {
		return x.InitialPadding
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetTrailingPadding() int32 {
	if x != nil {
		return x.TrailingPadding
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetSeekPreroll() int32 {
	if x != nil {
		return x.SeekPreroll
	}
	return 0
}

func (x *ProtoCameraStreamCodecs) GetStreamIndexUuid() string {
	if x != nil {
		return x.StreamIndexUuid
	}
	return ""
}

// Kafka topic: ${StreamUUID}_${StreamType}
// Key for Kafka message: ${MediaType}
// - StreamType: _main/_sub
// - MediaType: audio/video/data/subtitles/attachment
type ProtoPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// *
	// Time at which the decompressed packet will be presented to the user.
	// Can be AV_NOPTS_VALUE if it is not stored in the file.
	// pts MUST be larger or equal to dts as presentation cannot happen before decompression, unless one wants to view hex dumps.
	// Some formats misuse the terms dts and pts/cts to mean something different.
	// Such timestamps must be converted to true pts/dts before they are stored in AVPacket.
	Pts int64 `protobuf:"varint,1,opt,name=pts,proto3" json:"pts,omitempty"`
	// *
	// Decompression timestamp in AVStream->time_base units; the time at which
	// the packet is decompressed.
	// Can be AV_NOPTS_VALUE if it is not stored in the file.
	Dts         int64  `protobuf:"varint,2,opt,name=dts,proto3" json:"dts,omitempty"`
	Data        []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Size        int32  `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	StreamIndex int32  `protobuf:"varint,5,opt,name=stream_index,json=streamIndex,proto3" json:"stream_index,omitempty"`
	// *
	// A combination of AV_PKT_FLAG values
	Flags int32 `protobuf:"varint,6,opt,name=flags,proto3" json:"flags,omitempty"`
	// *
	// Additional packet data that can be provided by the container.
	// Packet can contain several types of side information.
	// This structure stores auxiliary information for decoding, presenting, or otherwise processing the coded stream. It is typically exported by demuxers and encoders and can be fed to decoders and muxers either in a per packet basis, or as global side data (applying to the entire coded stream).
	SideDataData  []byte `protobuf:"bytes,7,opt,name=side_data_data,json=sideDataData,proto3" json:"side_data_data,omitempty"`
	SideDataSize  uint64 `protobuf:"varint,8,opt,name=side_data_size,json=sideDataSize,proto3" json:"side_data_size,omitempty"`
	SideDataType  int32  `protobuf:"varint,9,opt,name=side_data_type,json=sideDataType,proto3" json:"side_data_type,omitempty"`
	SideDataElems int32  `protobuf:"varint,10,opt,name=side_data_elems,json=sideDataElems,proto3" json:"side_data_elems,omitempty"`
	// *
	// Duration of this packet in AVStream->time_base units, 0 if unknown.
	// Equals next_pts - this_pts in presentation order.
	Duration int64 `protobuf:"varint,11,opt,name=duration,proto3" json:"duration,omitempty"`
	// *
	// Byte position in stream, -1 if unknown
	Pos int64 `protobuf:"varint,12,opt,name=pos,proto3" json:"pos,omitempty"`
	// *
	// Time base of the packet's timestamps.
	//
	// @note fime_base = time_base_num / time_base_den
	// By default ignored on input to decoders or muxers.
	TimeBaseNum int32 `protobuf:"varint,13,opt,name=time_base_num,json=timeBaseNum,proto3" json:"time_base_num,omitempty"`
	TimeBaseDen int32 `protobuf:"varint,14,opt,name=time_base_den,json=timeBaseDen,proto3" json:"time_base_den,omitempty"`
}

func (x *ProtoPacket) Reset() {
	*x = ProtoPacket{}
	mi := &file_protoData_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoPacket) ProtoMessage() {}

func (x *ProtoPacket) ProtoReflect() protoreflect.Message {
	mi := &file_protoData_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtoPacket.ProtoReflect.Descriptor instead.
func (*ProtoPacket) Descriptor() ([]byte, []int) {
	return file_protoData_proto_rawDescGZIP(), []int{4}
}

func (x *ProtoPacket) GetPts() int64 {
	if x != nil {
		return x.Pts
	}
	return 0
}

func (x *ProtoPacket) GetDts() int64 {
	if x != nil {
		return x.Dts
	}
	return 0
}

func (x *ProtoPacket) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ProtoPacket) GetSize() int32 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *ProtoPacket) GetStreamIndex() int32 {
	if x != nil {
		return x.StreamIndex
	}
	return 0
}

func (x *ProtoPacket) GetFlags() int32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

func (x *ProtoPacket) GetSideDataData() []byte {
	if x != nil {
		return x.SideDataData
	}
	return nil
}

func (x *ProtoPacket) GetSideDataSize() uint64 {
	if x != nil {
		return x.SideDataSize
	}
	return 0
}

func (x *ProtoPacket) GetSideDataType() int32 {
	if x != nil {
		return x.SideDataType
	}
	return 0
}

func (x *ProtoPacket) GetSideDataElems() int32 {
	if x != nil {
		return x.SideDataElems
	}
	return 0
}

func (x *ProtoPacket) GetDuration() int64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *ProtoPacket) GetPos() int64 {
	if x != nil {
		return x.Pos
	}
	return 0
}

func (x *ProtoPacket) GetTimeBaseNum() int32 {
	if x != nil {
		return x.TimeBaseNum
	}
	return 0
}

func (x *ProtoPacket) GetTimeBaseDen() int32 {
	if x != nil {
		return x.TimeBaseDen
	}
	return 0
}

var File_protoData_proto protoreflect.FileDescriptor

var file_protoData_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x05, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xf8, 0x01, 0x0a, 0x12, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x44, 0x69, 0x67, 0x65, 0x73, 0x74, 0x12,
	0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x75, 0x75, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x55, 0x75,
	0x69, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x2e,
	0x0a, 0x13, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x1c,
	0x0a, 0x09, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x09, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x25, 0x0a, 0x0e,
	0x6c, 0x61, 0x73, 0x74, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x48, 0x65, 0x61, 0x72, 0x74, 0x62,
	0x65, 0x61, 0x74, 0x22, 0xe1, 0x02, 0x0a, 0x0b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x43, 0x61, 0x6d,
	0x65, 0x72, 0x61, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x5f, 0x75, 0x75,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61,
	0x55, 0x75, 0x69, 0x64, 0x12, 0x22, 0x0a, 0x0d, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x72, 0x74, 0x73,
	0x70, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6d, 0x61, 0x69,
	0x6e, 0x52, 0x74, 0x73, 0x70, 0x55, 0x72, 0x6c, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x61, 0x69, 0x6e,
	0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x61, 0x69, 0x6e, 0x43, 0x6f, 0x6e, 0x6e,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x0c, 0x73, 0x75,
	0x62, 0x5f, 0x72, 0x74, 0x73, 0x70, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0a, 0x73, 0x75, 0x62, 0x52, 0x74, 0x73, 0x70, 0x55, 0x72, 0x6c, 0x12, 0x2e, 0x0a, 0x13,
	0x73, 0x75, 0x62, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x73, 0x75, 0x62, 0x43, 0x6f,
	0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x0b,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x32, 0x0a,
	0x15, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x5f, 0x75, 0x75, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x63, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x55, 0x75, 0x69,
	0x64, 0x12, 0x34, 0x0a, 0x16, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x5f, 0x72, 0x65, 0x74,
	0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x14, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x52, 0x65, 0x74, 0x65, 0x6e, 0x74,
	0x69, 0x6f, 0x6e, 0x44, 0x61, 0x79, 0x73, 0x22, 0x90, 0x02, 0x0a, 0x1b, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x3f, 0x0a, 0x1c, 0x63, 0x61, 0x6d, 0x65, 0x72,
	0x61, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x61,
	0x74, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x19, 0x63,
	0x61, 0x6d, 0x65, 0x72, 0x61, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x76, 0x69, 0x64, 0x65,
	0x6f, 0x5f, 0x61, 0x76, 0x67, 0x5f, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0f, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x41, 0x76, 0x67, 0x42, 0x69, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x62, 0x69,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x76, 0x69, 0x64,
	0x65, 0x6f, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x69, 0x64,
	0x65, 0x6f, 0x5f, 0x66, 0x70, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08, 0x76, 0x69,
	0x64, 0x65, 0x6f, 0x46, 0x70, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f,
	0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x76, 0x69, 0x64,
	0x65, 0x6f, 0x57, 0x69, 0x64, 0x74, 0x68, 0x12, 0x21, 0x0a, 0x0c, 0x76, 0x69, 0x64, 0x65, 0x6f,
	0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x76,
	0x69, 0x64, 0x65, 0x6f, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0xd3, 0x09, 0x0a, 0x17, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x43, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
	0x43, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x5f,
	0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x63, 0x6f, 0x64, 0x65,
	0x63, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x5f, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x49, 0x64,
	0x12, 0x1b, 0x0a, 0x09, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x54, 0x61, 0x67, 0x12, 0x1c, 0x0a,
	0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x25, 0x0a, 0x0e, 0x65,
	0x78, 0x74, 0x72, 0x61, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x0d, 0x65, 0x78, 0x74, 0x72, 0x61, 0x64, 0x61, 0x74, 0x61, 0x53, 0x69,
	0x7a, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x6f,
	0x72, 0x6d, 0x61, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0a, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x62,
	0x69, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x62,
	0x69, 0x74, 0x52, 0x61, 0x74, 0x65, 0x12, 0x31, 0x0a, 0x15, 0x62, 0x69, 0x74, 0x73, 0x5f, 0x70,
	0x65, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x12, 0x62, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x43, 0x6f,
	0x64, 0x65, 0x64, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x2d, 0x0a, 0x13, 0x62, 0x69, 0x74,
	0x73, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x72, 0x61, 0x77, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
	0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x62, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x52,
	0x61, 0x77, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x66,
	0x69, 0x6c, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x66, 0x69,
	0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x0c, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74,
	0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x16,
	0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06,
	0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x35, 0x0a, 0x17, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
	0x5f, 0x61, 0x73, 0x70, 0x65, 0x63, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x5f, 0x6e, 0x75,
	0x6d, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x05, 0x52, 0x14, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x41,
	0x73, 0x70, 0x65, 0x63, 0x74, 0x52, 0x61, 0x74, 0x69, 0x6f, 0x4e, 0x75, 0x6d, 0x12, 0x35, 0x0a,
	0x17, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x61, 0x73, 0x70, 0x65, 0x63, 0x74, 0x5f, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x5f, 0x64, 0x65, 0x6e, 0x18, 0x10, 0x20, 0x01, 0x28, 0x05, 0x52, 0x14,
	0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x41, 0x73, 0x70, 0x65, 0x63, 0x74, 0x52, 0x61, 0x74, 0x69,
	0x6f, 0x44, 0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74,
	0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x11, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x66, 0x72, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x23, 0x0a, 0x0d, 0x66, 0x72, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x6e, 0x18, 0x12, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x44, 0x65, 0x6e, 0x12, 0x1f,
	0x0a, 0x0b, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x13, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x0a, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12,
	0x1f, 0x0a, 0x0b, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x14,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x12, 0x27, 0x0a, 0x0f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x5f, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x63, 0x6f, 0x6c, 0x6f, 0x72,
	0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x69, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x6f, 0x6c,
	0x6f, 0x72, 0x5f, 0x74, 0x72, 0x63, 0x18, 0x16, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x63, 0x6f,
	0x6c, 0x6f, 0x72, 0x54, 0x72, 0x63, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x5f,
	0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x17, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x6f, 0x6c,
	0x6f, 0x72, 0x53, 0x70, 0x61, 0x63, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x63, 0x68, 0x72, 0x6f, 0x6d,
	0x61, 0x5f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x18, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0e, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x1f, 0x0a, 0x0b, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x18,
	0x19, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x6c, 0x61,
	0x79, 0x12, 0x26, 0x0a, 0x0f, 0x63, 0x68, 0x5f, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x5f, 0x6f,
	0x72, 0x64, 0x65, 0x72, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0d, 0x63, 0x68, 0x4c, 0x61,
	0x79, 0x6f, 0x75, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x31, 0x0a, 0x15, 0x63, 0x68, 0x5f,
	0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x5f, 0x6e, 0x62, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x73, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x05, 0x52, 0x12, 0x63, 0x68, 0x4c, 0x61, 0x79, 0x6f,
	0x75, 0x74, 0x4e, 0x62, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x1f, 0x0a, 0x0b,
	0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x1c, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0a, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a,
	0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x18, 0x1d, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0a, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x41, 0x6c, 0x69, 0x67, 0x6e, 0x12, 0x1d,
	0x0a, 0x0a, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x1e, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x09, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x27, 0x0a,
	0x0f, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6e, 0x67,
	0x18, 0x1f, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x50,
	0x61, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x69,
	0x6e, 0x67, 0x5f, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x20, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0f, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x64, 0x64, 0x69, 0x6e,
	0x67, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x65, 0x6b, 0x5f, 0x70, 0x72, 0x65, 0x72, 0x6f, 0x6c,
	0x6c, 0x18, 0x21, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x73, 0x65, 0x65, 0x6b, 0x50, 0x72, 0x65,
	0x72, 0x6f, 0x6c, 0x6c, 0x12, 0x2a, 0x0a, 0x11, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x5f, 0x75, 0x75, 0x69, 0x64, 0x18, 0x22, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x55, 0x75, 0x69, 0x64,
	0x22, 0xa2, 0x03, 0x0a, 0x0b, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x12, 0x10, 0x0a, 0x03, 0x70, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x70,
	0x74, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x03, 0x64, 0x74, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x21, 0x0a, 0x0c,
	0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0b, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x14, 0x0a, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05,
	0x66, 0x6c, 0x61, 0x67, 0x73, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x69, 0x64, 0x65, 0x5f, 0x64, 0x61,
	0x74, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x73,
	0x69, 0x64, 0x65, 0x44, 0x61, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61, 0x12, 0x24, 0x0a, 0x0e, 0x73,
	0x69, 0x64, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0c, 0x73, 0x69, 0x64, 0x65, 0x44, 0x61, 0x74, 0x61, 0x53, 0x69, 0x7a,
	0x65, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x69, 0x64, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x73, 0x69, 0x64, 0x65, 0x44,
	0x61, 0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x73, 0x69, 0x64, 0x65, 0x5f,
	0x64, 0x61, 0x74, 0x61, 0x5f, 0x65, 0x6c, 0x65, 0x6d, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0d, 0x73, 0x69, 0x64, 0x65, 0x44, 0x61, 0x74, 0x61, 0x45, 0x6c, 0x65, 0x6d, 0x73, 0x12,
	0x1a, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x70,
	0x6f, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x70, 0x6f, 0x73, 0x12, 0x22, 0x0a,
	0x0d, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x42, 0x61, 0x73, 0x65, 0x4e, 0x75,
	0x6d, 0x12, 0x22, 0x0a, 0x0d, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x64,
	0x65, 0x6e, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x42, 0x61,
	0x73, 0x65, 0x44, 0x65, 0x6e, 0x42, 0x02, 0x48, 0x03, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_protoData_proto_rawDescOnce sync.Once
	file_protoData_proto_rawDescData = file_protoData_proto_rawDesc
)

func file_protoData_proto_rawDescGZIP() []byte {
	file_protoData_proto_rawDescOnce.Do(func() {
		file_protoData_proto_rawDescData = protoimpl.X.CompressGZIP(file_protoData_proto_rawDescData)
	})
	return file_protoData_proto_rawDescData
}

var file_protoData_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_protoData_proto_goTypes = []any{
	(*ProtoServiceDigest)(nil),          // 0: proto.ProtoServiceDigest
	(*ProtoCamera)(nil),                 // 1: proto.ProtoCamera
	(*ProtoCameraStreamParameters)(nil), // 2: proto.ProtoCameraStreamParameters
	(*ProtoCameraStreamCodecs)(nil),     // 3: proto.ProtoCameraStreamCodecs
	(*ProtoPacket)(nil),                 // 4: proto.ProtoPacket
}
var file_protoData_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_protoData_proto_init() }
func file_protoData_proto_init() {
	if File_protoData_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_protoData_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_protoData_proto_goTypes,
		DependencyIndexes: file_protoData_proto_depIdxs,
		MessageInfos:      file_protoData_proto_msgTypes,
	}.Build()
	File_protoData_proto = out.File
	file_protoData_proto_rawDesc = nil
	file_protoData_proto_goTypes = nil
	file_protoData_proto_depIdxs = nil
}
